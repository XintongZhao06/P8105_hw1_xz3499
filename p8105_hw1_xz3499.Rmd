---
title: "p8105_hw1_xz3499.Rmd"
author: "Xintong Zhao"
date: '2025-9-13'
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Problem 1

### 1. Load required libraries
```{r, message=FALSE}
library(moderndive)
library(ggplot2)
library(dplyr)
```

### 2. Load the dataset
```{r}
data("early_january_weather")
```

### 3. View basic dataset information
```{r}
# quickly view the data
summary(early_january_weather)
```
### 4. A short discription of the dataset
The dataset contains the following variables: `r paste(names(early_january_weather), collapse = ", ")`. The important variables include: temp, dewp, and humid, which are core variables describing the atmospheric state with relatively uniform distributions; wind_dir and wind_speed, which are key indicators reflecting wind conditions; precip, which is zero for most of the time; pressure has a significant number of missing values, while visib exhibits a wide range of distribution.

The dataset has `r nrow(early_january_weather)` rows and `r ncol(early_january_weather)` columns.

The mean temperature is `r round(mean(early_january_weather$temp, na.rm = TRUE), 1)`°F.

### 5. Create scatterplot
```{r}
scatter_plot <- ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point() +
  labs(x = "Time", y = "Temperature (°F)", color = "Humidity") +
  theme_minimal()

# display the plot
print(scatter_plot)

# save the plot
ggsave("temp_vs_time.png", plot = scatter_plot, width = 8, height = 6)
```

### 6. Apparent patterns in the plot

a. **Cyclical Temperature Pattern**: The temperature shows obvious daily periodic fluctuations. Corresponding to the diurnal cycle, the temperature rises during the day and drops at night.

b. **Humidity-Temperature Relationship**: Generally, there is an inversely proportional relationship between temperature and humidity. When the temperature is low, the humidity is often high.

c. **Trend Over Time**: From January 7th to January 15th, the temperature generally showed a gradually warming trend.

d. **Consistent Daily Range**: The daily temperature difference is relatively stable during this period.

## Problem 2

### 1. Load required libraries
```{r, message=FALSE}
library(tidyverse)
```

### 2. Create the dataframe
```{r}
set.seed(123)

df <- tibble(
  norm_sample = rnorm(10),
  logical_vec = norm_sample > 0,
  char_vec = letters[1:10],
  factor_vec = factor(rep(c("Low", "Medium", "High"), length.out = 10))
)

print(df)
```

### 3. Take the mean of each variable
```{r}
# Use pull() to extract each column from the data frame df, calculate the average value of each vector, and store the result in a variable starting with mean_
mean_norm <- mean(pull(df, norm_sample))
mean_logical <- mean(pull(df, logical_vec))
# Use the try() function to catch errors. 
mean_char <- try(mean(pull(df, char_vec)), silent = TRUE)
mean_factor <- try(mean(pull(df, factor_vec)), silent = TRUE)

cat("Mean of norm_sample:", mean_norm, "\n")
cat("Mean of logical_vec:", mean_logical, "\n")
cat("Mean of char_vec:", mean_char, "\n")
cat("Mean of factor_vec:", mean_factor, "\n")
```

### 4. Convert variables to numbers
```{r, message=FALSE}
num_logical <- as.numeric(pull(df, logical_vec))
num_char <- as.numeric(pull(df, char_vec))
num_factor <- as.numeric(pull(df, factor_vec))
```

* What happens and why?

    * Logical variables: TRUE is converted to 1, and FALSE is converted to 0. Because R internally represents logical values in binary.

    * Character variables: Convert all characters to NA. Because characters such as letters cannot be parsed into numerical values.

    * Factor variable: Factors are converted to the underlying integer codes. Because factors are internally stored as integers representing category information in R.

* This helps explain what happens when taking the mean of variables:

    * Numerical variable: The mean is calculated normally.

    * Logical variables: R will automatically convert TRUE/FALSE to 1/0 before calculation.

    * Character variable: Characters cannot be parsed as numbers, so mean() cannot calculate and returns NA.

    * Factor variable: The mean() function does not automatically convert factors to their underlying integer codes, resulting in an inability to compute the mean.